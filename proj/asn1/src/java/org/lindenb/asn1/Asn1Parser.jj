/**
 *  A custom ASN.1 parser just for fun
 *  When I got time, I'll finish to write this
 * http://www.obj-sys.com/asn1tutorial/node11.html
 * http://www.ncbi.nlm.nih.gov/data_specs/asn/cdd.asn
 */
 
options {
	JDK_VERSION = "1.6";
	STATIC=false;
	}

PARSER_BEGIN(Asn1Parser)

package org.lindenb.asn1;
import java.net.URL;
import java.util.*;



/**
 *
 * Asn1Parser
 *
 */
public class Asn1Parser
{

/**
 *
 * ASN1 Module
 *
 */
public static class Module
	implements Iterable<NamedType>
	{
	private java.util.List<NamedType> types =  new java.util.ArrayList<NamedType>();
	public NamedType get(int i)
		{
		return this.types.get(i);
		}
	
	public NamedType findTypeByName(String name)
		{
		for(int i=0;i< size();++i) if(get(i).getName().equals(name))
			{
			return get(i);
			}
		return null;
		}
	
	public int size()
		{
		return this.types.size();
		}
		
	public Iterator<NamedType> iterator()
		{
		return this.types.iterator();
		}
	}

public static abstract class DataType
	{
	protected DataType()
		{
		}
	}

public static abstract  class SimpleType extends DataType
	{
	protected SimpleType()
		{
		}
	}


public static abstract class ComplexType
	extends DataType
	implements Iterable<ComplexNamedType>
	{
	java.util.List<ComplexNamedType> columns= null;
	
	protected ComplexType(java.util.List<ComplexNamedType> columns)
		{
		this.columns=columns;
		}
	
	public ComplexNamedType get(int i)
		{
		return this.columns.get(i);
		}
	
	public ComplexNamedType findTypeByName(String name)
		{
		for(int i=0;i< size();++i) if(get(i).getName().equals(name))
			{
			return get(i);
			}
		return null;
		}
	
	public int size()
		{
		return this.columns.size();
		}
		
	public Iterator<ComplexNamedType> iterator()
		{
		return this.columns.iterator();
		}
	}

public static class Choice extends ComplexType
	{
	Choice(java.util.List<ComplexNamedType> columns)
		{
		super(columns);
		}
	}

public static class Sequence extends ComplexType
	{
	Sequence(java.util.List<ComplexNamedType> columns)
		{
		super(columns);
		}
	}

public static class CollectionOf extends DataType
	{
	private DataType range;
	protected CollectionOf(DataType range)
		{
		this.range=range;
		}
	public DataType getRange()
		{
		return this.range;
		}
	}

public static class SequenceOf extends CollectionOf
	{
	SequenceOf(DataType range)
		{
		super(range);
		}
	}

public static class SetOf extends CollectionOf
	{
	SetOf(DataType range)
		{
		super(range);
		}
	}

public static class ChoiceOf extends CollectionOf
	{
	ChoiceOf(DataType range)
		{
		super(range);
		}
	}

public static class IntegerType extends SimpleType
	{
	java.util.Map<Integer,String> id2enum =null;
	Integer defaultValue=null;
	}

public static class VisibleString extends SimpleType
	{
	
	}

public static class OctetString extends SimpleType
	{
	
	}


public static class BooleanType extends SimpleType
	{
	Boolean defaultValue=null;
	}

public static class RealType extends SimpleType
	{
	
	}

public static class EnumerationType extends SimpleType
	{
	java.util.Map<Integer,String> id2enum =null;
	Integer defaultValue=null;
	}

public static class ReferenceType extends DataType
	{
	private String typename;
	ReferenceType(String typename)
		{
		this.typename=typename;
		}
	public String getTypeName()
		{
		return this.typename;
		}
	}


/**
 *
 */
public static class NamedType
	{
	private String name;
	private DataType type;
	
	NamedType(String name,DataType type)
		{
		this.name=name;
		this.type=type;
		}
	
	public String getName()
		{
		return this.name;
		}
	public DataType getDataType()
		{
		return this.type;
		}
	}

public static class ComplexNamedType
	extends NamedType
	{
	private boolean optional=false;
	ComplexNamedType(String name,DataType type,boolean optional)
		{
		super(name,type);
		this.optional=optional;
		}
	public boolean isOptional()
		{
		return this.optional;
		}
	}


public Asn1Parser(URL url) throws java.io.IOException
	{
	this(url.openStream());
	}

public static void main(String args[])
  	{
  	try
  		{
  		Asn1Parser parser = new Asn1Parser(new URL("http://www.ncbi.nlm.nih.gov/data_specs/asn/NCBI_all.asn"));
  		Module module=parser.module();
  		}
  	catch(Throwable err)
  		{
  		err.printStackTrace();
  		}
	}
}
PARSER_END(Asn1Parser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
| 	"--": WithinComment
}

<WithinComment> SKIP:
{
    "\n": DEFAULT
|   "\r": DEFAULT
|    <~[]>
}

TOKEN :
{
	< ANY: "ANY" >
|	< BEGIN: "BEGIN" >
|	< BOOLEAN: "BOOLEAN" >
|	< CHOICE: "CHOICE" >
|	< DEFAULTVALUE: "DEFAULT" >
|	< DEFINITIONS: "DEFINITIONS" >
|	< ENUMERATED: "ENUMERATED" >
|	< END: "END" >
|	< EXPORTS: "EXPORTS" >
|	< FALSE: "FALSE" >
|	< FROM: "FROM" >
|	< IMPORTS: "IMPORTS" >
|	< INTEGER: "INTEGER" >
|	< NILL: "NULL" >
|	< OCTET: "OCTET" >
|	< OPTIONAL: "OPTIONAL" >
|	< OF: "OF" >
|	< REAL: "REAL" >
|	< SELECTION: "SELECTION" >
|	< SEQUENCE: "SEQUENCE" >
|	< SET: "SET" >
|	< STRING: "STRING" >
|	< TRUE: "TRUE" >
|	< VISIBLESTRING: "VisibleString" >
|	< DECL: "::=" >
|	< OB: "{" >
|	< CB: "}" >
|	< OP: "(" >
|	< CP: ")" >
|	< OA: "[" >
|	< CA: "]" >
|	< COMMA: "," >
|	< SEMICOLON: ";" >
}

TOKEN:
{
	<#LETTER: (["A"-"Z"]|["a"-"z"])>
|	<#DIGIT: (["0"-"9"])>
|	<IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"-"|"_")*>
|	<INT_VALUE: (<DIGIT>)+>
}


Module module():
	{
	List<NamedType> definitions=null;
	}
	{
	<IDENTIFIER> <DEFINITIONS> <DECL> <BEGIN> (exports())? (imports())? definitions=definition_body() <END> 
		{
		Module module=new Module();
		module.types = definitions;
		return module;
		}
	}

void exports():
	{
	}
	{
	<EXPORTS> <IDENTIFIER> (<COMMA> <IDENTIFIER> )* <SEMICOLON>
	}



void imports():
	{
	}
	{
	<IMPORTS> importSet() (importSet() )*  <SEMICOLON>
	}

void importSet():
	{
	}
	{
	<IDENTIFIER> (<COMMA> <IDENTIFIER> )* <FROM> <IDENTIFIER>
	}

List<NamedType> definition_body():
	{
	List<NamedType> types= new ArrayList<NamedType>();
	Set<String> seen= new HashSet<String>();
	NamedType t1=null;
	NamedType t2=null;
	}
	{
	t1=typeDecl() { types.add(t1); seen.add(t1.getName());} ( t2=typeDecl()
			{
			if(seen.contains(t2.getName())) throw new ParseException("Duplicate Name  "+t2.getName() );
			types.add(t2);
			seen.add(t2.getName());
			})*
		{
		return types;
		}
	}

NamedType typeDecl():
	{
	String name=null;
	DataType datatype=null;
	}
	{
	name = identifier() <DECL> datatype=anyType()
		{
		return new NamedType(name,datatype);
		}
	}

DataType anyType():
	{
	DataType dt=null;
	}
	{
	(	dt= sequenceOfType()
	|	dt= choiceOfType()
	|	dt= setOfType()
	|	dt= enumType()
	|	dt= referenceType()
	|	dt= visibleStringType()
	|	dt= octetString()
	|	dt= integerType()
	|	dt= booleanType()
	|	dt= realType()
	)	{
		return dt;
		}
	}

ReferenceType referenceType():
	{
	String id;
	}
	{
	id=identifier()
		{
		return new ReferenceType(id);
		}
	}

DataType sequenceOfType():
	{
	List<ComplexNamedType> columns=null;
	DataType range=null;
	}
	{
	<SEQUENCE>
		(
			<OF> range=anyType()
				{
				return new SequenceOf(range);
				}
		| 	<OB> columns=complexContent() <CB>
				{
				return new Sequence(columns);
				}
		)
	}

DataType choiceOfType():
	{
	DataType range=null;
	List<ComplexNamedType> columns=null;
	}
	{
	<CHOICE>
		(
			<OF> range=anyType()
				{
				return new ChoiceOf(range);
				}
		|	<OB> columns=complexContent() <CB>
				{
				return new Choice(columns);
				}
		)
	}



SetOf setOfType():
	{
	DataType range=null;
	}
	{
	<SET>  <OF> range=anyType()
		{
		return new SetOf(range);
		}
	}

EnumerationType enumType():
	{
	String defaultValue=null;
	Map<Integer,String> id2enum=null;
	}
	{
	<ENUMERATED> id2enum=integerEnum() (<DEFAULTVALUE> defaultValue=identifier() )?
		{
		EnumerationType t=  new EnumerationType();
		Integer defaultInt=null;
		t.id2enum=id2enum;
		if(defaultValue!=null)
			{
			for(Integer key: t.id2enum.keySet())
				{
				if( t.id2enum.get(key).equals( defaultValue ) )
					{
					defaultInt=key;
					break;
					}
				}
			if( defaultInt==null)
				{
				 throw new ParseException("Cannot find default value "+defaultValue );
				}
			}
		t.defaultValue=defaultInt;

		return t;
		}
	
	}


OctetString octetString():
	{
	}
	{
	<OCTET> <STRING> {
		return new OctetString();
		}
	}


VisibleString visibleStringType():
	{
	}
	{
	<VISIBLESTRING> {
		return new VisibleString();
		}
	}


IntegerType integerType():
	{
	Integer defaultInt=null;
	String defaultValue=null;
	Map<Integer,String> id2enum=null;
	}
	{
	<INTEGER> ( id2enum=integerEnum()  (<DEFAULTVALUE> defaultValue=identifier())? | <DEFAULTVALUE> defaultInt=intValue() )?
		{
		IntegerType t= new IntegerType();
		t.id2enum=id2enum;
		if(t.id2enum!=null && defaultValue!=null)
			{
			for(Integer key: t.id2enum.keySet())
				{
				if( t.id2enum.get(key).equals( defaultValue ) )
					{
					defaultInt=key;
					break;
					}
				}
			if( defaultInt==null)
				{
				throw new ParseException("Cannot find default value "+defaultValue );
				}
			}
		t.defaultValue=defaultInt;
		return t;
		}
	}

BooleanType booleanType():
	{
	Boolean defaultValue=null;
	}
	{
	<BOOLEAN>  (<DEFAULTVALUE> defaultValue=booleanValue() )?
		{
		BooleanType b= new BooleanType();
		b.defaultValue=defaultValue;
		return b;
		}
	}

RealType realType():
	{
	}
	{
	<REAL> { return new RealType(); }
	}


List<ComplexNamedType> complexContent():
	{
	List<ComplexNamedType> columns= new ArrayList<ComplexNamedType>();
	ComplexNamedType c1=null;
	ComplexNamedType c2=null;
	}
	{
	c1=complexField()
		{
		columns.add(c1);
		} (<COMMA> c2=complexField()
			{
			for(ComplexNamedType c: columns)
				{
				if(c.getName().equals(c2.getName()))
					{
					throw new ParseException("duplicate name "+c2 );
					}
				}
			columns.add(c2);
			})*
		{
		return columns;
		}
	}


ComplexNamedType complexField():
	{
	String fieldName;
	DataType type;
	boolean optional=false;
	}
	{
	fieldName = identifier() type = anyType() (<OPTIONAL> { optional=true; })?
		{
		return new ComplexNamedType(fieldName,type,optional);
		}
	}




Map<Integer,String> integerEnum():
	{
	Map<Integer,String> id2enum=new TreeMap<Integer,String>();
	Map.Entry<Integer,String> entry1=null;
	Map.Entry<Integer,String> entry2=null;
	}
	{
	<OB> entry1=enumItem()
		{
		id2enum.put(entry1.getKey(),entry1.getValue());
		}(<COMMA> entry2=enumItem()
			{
			if( id2enum.containsKey( entry2.getKey())) throw new ParseException("Duplicate key "+entry2.getKey() );
			for(Integer k: id2enum.keySet())
				{
				if( id2enum.get(k).equals(entry2.getValue())) throw new ParseException("Duplicate value "+entry2.getValue() );
				}
			id2enum.put(entry2.getKey(),entry2.getValue());
			})* <CB>
		{
		
		return id2enum;
		}
	}

Map.Entry<Integer,String> enumItem():
	{
	String value=null;
	Integer key=null;
	}
	{
	value=identifier() <OP> key=intValue() <CP>
		{
		return new AbstractMap.SimpleEntry<Integer,String>(key,value);
		}
	}

Integer intValue():
	{
	Token t;
	}
	{
	t=<INT_VALUE>
		{
		return new Integer(t.image);
		}
	}

boolean booleanValue():
	{
	}
	{
		<TRUE> { return true;}
	|	<FALSE> { return false;}
	}

String identifier():
	{
	Token t;
	}
	{
	t=<IDENTIFIER>
		{
		return t.image;
		}
	}



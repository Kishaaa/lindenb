/**
 *  A custom ASN.1 parser just for fun
 *  When I got time, I'll finish to write this
 * http://www.obj-sys.com/asn1tutorial/node11.html
 * http://www.ncbi.nlm.nih.gov/data_specs/asn/cdd.asn
 */
 
options {
	JDK_VERSION = "1.6";
	STATIC=false;
	LOOKAHEAD=2;
	}

PARSER_BEGIN(Asn1Parser)

//package org.lindenb.asn1;
import java.net.URL;
import java.util.*;



/**
 *
 * Asn1Parser
 *
 */
public class Asn1Parser
{
/** parent parser */
private Asn1Parser owner;

public class DataType
	{
	}

public class SimpleType extends DataType
	{
	}


public class ComplexType extends DataType
	{
	private java.util.List<NamedType> columns= new java.util.ArrayList();
	}

public class ChoiceType extends ComplexType
	{
	}

public class SequenceType extends ComplexType
	{
	}

public class CollectionOf extends DataType
	{
	}

public class SequenceOf extends CollectionOf
	{
	}

public class SetOf extends CollectionOf
	{
	}

public class IntegerType extends SimpleType
	{
	java.util.Map<Integer,String> id2enum =null;
	Integer defaultValue=null;
	}

public class VisibleString extends SimpleType
	{
	
	}

public class OctetString extends SimpleType
	{
	
	}


public class BooleanType extends SimpleType
	{
	Boolean defaultValue=null;
	}

public class RealType extends SimpleType
	{
	
	}

public class EnumerationType extends SimpleType
	{
	java.util.Map<Integer,String> id2enum =null;
	Integer defaultValue=null;
	}


class NamedType
	{
	String name;
	DataType type;
	}




public Asn1Parser(URL url) throws java.io.IOException
	{
	this(null,url);
	}

public Asn1Parser(Asn1Parser owner,URL url) throws java.io.IOException
	{
	this(url.openStream());
	this.owner=owner;
	}

public static void main(String args[])
  	{
  	try
  		{
  		Asn1Parser parser = new Asn1Parser(new URL("http://www.ncbi.nlm.nih.gov/data_specs/asn/NCBI_all.asn"));
  		parser.input();
  		}
  	catch(Throwable err)
  		{
  		err.printStackTrace();
  		}
	}
}
PARSER_END(Asn1Parser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
| 	"--": WithinComment
}

<WithinComment> SKIP:
{
    "\n": DEFAULT
|   "\r": DEFAULT
|    <~[]>
}

TOKEN :
{
	< ANY: "ANY" >
|	< BEGIN: "BEGIN" >
|	< BOOLEAN: "BOOLEAN" >
|	< CHOICE: "CHOICE" >
|	< DEFAULTVALUE: "DEFAULT" >
|	< DEFINITIONS: "DEFINITIONS" >
|	< ENUMERATED: "ENUMERATED" >
|	< END: "END" >
|	< EXPORTS: "EXPORTS" >
|	< FALSE: "FALSE" >
|	< FROM: "FROM" >
|	< IMPORTS: "IMPORTS" >
|	< INTEGER: "INTEGER" >
|	< NILL: "NULL" >
|	< OCTET: "OCTET" >
|	< OPTIONAL: "OPTIONAL" >
|	< OF: "OF" >
|	< REAL: "REAL" >
|	< SELECTION: "SELECTION" >
|	< SEQUENCE: "SEQUENCE" >
|	< SET: "SET" >
|	< STRING: "STRING" >
|	< TRUE: "TRUE" >
|	< VISIBLESTRING: "VisibleString" >
|	< DECL: "::=" >
|	< OB: "{" >
|	< CB: "}" >
|	< OP: "(" >
|	< CP: ")" >
|	< OA: "[" >
|	< CA: "]" >
|	< COMMA: "," >
|	< SEMICOLON: ";" >
}

TOKEN:
{
	<#LETTER: (["A"-"Z"]|["a"-"z"])>
|	<#DIGIT: (["0"-"9"])>
|	<IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"-"|"_")*>
|	<INT_VALUE: (<DIGIT>)+>
}

void input():
	{
	}
	{
	definition()
	}

void definition():
	{
	}
	{
	<IDENTIFIER> <DEFINITIONS> <DECL> <BEGIN> (exports())? (imports())? definition_body() <END> 
	}

void exports():
	{
	}
	{
	<EXPORTS> <IDENTIFIER> (<COMMA> <IDENTIFIER> )* <SEMICOLON>
	}



void imports():
	{
	}
	{
	<IMPORTS> importSet() (importSet() )*  <SEMICOLON>
	}

void importSet():
	{
	}
	{
	<IDENTIFIER> (<COMMA> <IDENTIFIER> )* <FROM> <IDENTIFIER>
	}

void definition_body():
	{
	}
	{
	typeDecl() ( typeDecl())*
	}

void typeDecl():
	{
	}
	{
	<IDENTIFIER> <DECL> anyType()
	}

void anyType():
	{
	}
	{
		sequenceOfType()
	|	choiceOfType()
	|	setOfType()
	|	enumType()
	|	identifier()
	|	visibleStringType()
	|	octetString()
	|	integerType()
	|	booleanType()
	|	realType()
	}


void sequenceOfType():
	{
	List<NamedType> columns=null;
	}
	{
	<SEQUENCE> ( <OF> anyType() | <OB> columns=complexContent() <CB> )
	}

void choiceOfType():
	{
	List<NamedType> columns=null;
	}
	{
	<CHOICE> ( <OF> anyType() | <OB> columns=complexContent() <CB> )
	}



void setOfType():
	{
	}
	{
	<SET>  <OF> anyType()
	}

EnumerationType enumType():
	{
	String defaultValue=null;
	Map<Integer,String> id2enum=null;
	}
	{
	<ENUMERATED> id2enum=integerEnum() (<DEFAULTVALUE> defaultValue=identifier() )?
		{
		EnumerationType t=  new EnumerationType();
		Integer defaultInt=null;
		t.id2enum=id2enum;
		if(defaultValue!=null)
			{
			for(Integer key: t.id2enum.keySet())
				{
				if( t.id2enum.get(key).equals( defaultValue ) )
					{
					defaultInt=key;
					break;
					}
				}
			if( defaultInt==null)
				{
				 throw new ParseException("Cannot find default value "+defaultValue );
				}
			}
		t.defaultValue=defaultInt;

		return t;
		}
	
	}


OctetString octetString():
	{
	}
	{
	<OCTET> <STRING> {
		return new OctetString();
		}
	}


VisibleString visibleStringType():
	{
	}
	{
	<VISIBLESTRING> {
		return new VisibleString();
		}
	}


IntegerType integerType():
	{
	Integer defaultInt=null;
	String defaultValue=null;
	Map<Integer,String> id2enum=null;
	}
	{
	<INTEGER> ( id2enum=integerEnum()  (<DEFAULTVALUE> defaultValue=identifier())? | <DEFAULTVALUE> defaultInt=intValue() )?
		{
		IntegerType t= new IntegerType();
		t.id2enum=id2enum;
		if(t.id2enum!=null && defaultValue!=null)
			{
			for(Integer key: t.id2enum.keySet())
				{
				if( t.id2enum.get(key).equals( defaultValue ) )
					{
					defaultInt=key;
					break;
					}
				}
			if( defaultInt==null)
				{
				 throw new ParseException("Cannot find default value "+defaultValue );
				}
			}
		t.defaultValue=defaultInt;
		return t;
		}
	}

BooleanType booleanType():
	{
	Boolean defaultValue=null;
	}
	{
	<BOOLEAN>  (<DEFAULTVALUE> defaultValue=booleanValue() )?
		{
		BooleanType b= new BooleanType();
		b.defaultValue=defaultValue;
		return b;
		}
	}

RealType realType():
	{
	}
	{
	<REAL> { return new RealType(); }
	}


List<NamedType> complexContent():
	{
	List<NamedType> columns= new ArrayList<NamedType>();
	}
	{
	complexField() (<COMMA> complexField())*
		{
		return columns;
		}
	}


void complexField():
	{
	String fieldName;
	boolean optional=false;
	}
	{
	fieldName = identifier() anyType() (<OPTIONAL> { optional=true; })?
		{
		
		}
	}




Map<Integer,String> integerEnum():
	{
	Map<Integer,String> id2enum=new TreeMap<Integer,String>();
	Map.Entry<Integer,String> entry1=null;
	Map.Entry<Integer,String> entry2=null;
	}
	{
	<OB> entry1=enumItem()
		{
		id2enum.put(entry1.getKey(),entry1.getValue());
		}(<COMMA> entry2=enumItem()
			{
			if( id2enum.containsKey( entry2.getKey())) throw new ParseException("Duplicate key "+entry2.getKey() );
			for(Integer k: id2enum.keySet())
				{
				if( id2enum.get(k).equals(entry2.getValue())) throw new ParseException("Duplicate value "+entry2.getValue() );
				}
			id2enum.put(entry2.getKey(),entry2.getValue());
			})* <CB>
		{
		
		return id2enum;
		}
	}

Map.Entry<Integer,String> enumItem():
	{
	String value=null;
	Integer key=null;
	}
	{
	value=identifier() <OP> key=intValue() <CP>
		{
		return new AbstractMap.SimpleEntry<Integer,String>(key,value);
		}
	}

Integer intValue():
	{
	Token t;
	}
	{
	t=<INT_VALUE>
		{
		return new Integer(t.image);
		}
	}

boolean booleanValue():
	{
	}
	{
		<TRUE> { return true;}
	|	<FALSE> { return false;}
	}

String identifier():
	{
	Token t;
	}
	{
	t=<IDENTIFIER>
		{
		return t.image;
		}
	}


